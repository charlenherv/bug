{"remainingRequest":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/hervey/Projects/Development/audiomarketplace/src/components/audio/AudioTrimmer.vue?vue&type=style&index=0&id=5983bc0b&lang=scss&scoped=true&","dependencies":[{"path":"/Users/hervey/Projects/Development/audiomarketplace/src/components/audio/AudioTrimmer.vue","mtime":1631384392549},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/sass-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/hervey/Projects/Development/audiomarketplace/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5BdWRpb0Nyb3BwZXJfRnJhbWUgewogICAgcG9zaXRpb246IHJlbGF0aXZlOwogICAgaGVpZ2h0OiA0MHB4OwogICAgd2lkdGg6IDEwMCU7CiAgICBib3JkZXItcmFkaXVzOiAxMHB4OwogICAgYmFja2dyb3VuZDogbGlnaHRncmF5OwogICAgdHJhbnNpdGlvbjogYWxsIDFzOwogICAgLkF1ZGlvQ3JvcHBlcl9Dcm9wIHsKICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgcG9zaXRpb246IGFic29sdXRlOwogICAgICAgIHdpZHRoOiAxMDAlOwogICAgICAgIGhlaWdodDogMTAwJTsKICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoNDgsIDEzMSwgMjU1KTsKICAgIH0KfQoudWktcmVzaXphYmxlLWhhbmRsZSB7CiAgICB6LWluZGV4OiAyOwogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgdG9wOjA7CiAgICBoZWlnaHQ6IDEwMCU7CiAgICB3aWR0aDoxMi41cHg7CiAgICAmI0Nyb3BfTGVmdCB7CiAgICAgICAgbGVmdDogMDsKICAgICAgICAmOmJlZm9yZSB7CiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBsZWZ0OwogICAgICAgIH0KICAgIH0KICAgICYjQ3JvcF9SaWdodCB7CiAgICAgICAgcmlnaHQ6MDsKICAgICAgICAmOmJlZm9yZSB7CiAgICAgICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciByaWdodDsKICAgICAgICB9CiAgICB9CiAgICAuVGltZU1hcmtlciB7CiAgICAgICAgZGlzcGxheTogbm9uZTsKICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7CiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDsKICAgICAgICBsaW5lLWhlaWdodDogMTcuNXB4OwogICAgICAgIGhlaWdodDogMTcuNXB4OwogICAgICAgIHBhZGRpbmc6IDAgNXB4OwogICAgICAgIGZvbnQtc2l6ZTogNjUlOwogICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkOwogICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMjYsIDc0LCAxNDUpOwogICAgICAgICYuVGltZVN0YXJ0IHsKICAgICAgICAgICAgdG9wOiAwOwogICAgICAgICAgICBsZWZ0OiAwOwogICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTsKICAgICAgICAgICAgJltkYXRhLXNpZGU9ImxlZnQiXSB7CiAgICAgICAgICAgICAgICBsZWZ0OiBhdXRvOwogICAgICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTEwMCUsIDApOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgICYuVGltZUVuZCB7CiAgICAgICAgICAgIGJvdHRvbTogMDsKICAgICAgICAgICAgcmlnaHQ6MDsKICAgICAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7CiAgICAgICAgICAgICZbZGF0YS1zaWRlPSJyaWdodCJdIHsKICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKDEwMCUsIDApOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQogICAgJjpiZWZvcmUgewogICAgICAgIGNvbnRlbnQ6ICcnOwogICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICAgICAgICB0b3A6MDsKICAgICAgICBoZWlnaHQ6IDEwMCU7CiAgICAgICAgd2lkdGg6MTAwJTsKICAgICAgICBiYWNrZ3JvdW5kOiByZ2IoMjYsIDc0LCAxNDUpOwogICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjc1czsKICAgIH0KICAgICY6YWZ0ZXIgewogICAgICAgIGNvbnRlbnQ6ICcnOwogICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTsKICAgICAgICB0b3A6IDUwJTsKICAgICAgICBsZWZ0OiA1MCU7CiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwtNTAlKTsKICAgICAgICBoZWlnaHQ6IDc1JTsKICAgICAgICB3aWR0aDoycHg7CiAgICAgICAgYmFja2dyb3VuZDogcmdiYSgyNTUsMjU1LDI1NSwwLjEpOwogICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDsKICAgIH0KICAgICY6YWN0aXZlIHsKICAgIGN1cnNvcjogbm9uZTsKICAgICAgICAuVGltZU1hcmtlciB7CiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgICAgIH0KICAgICAgICAmOmJlZm9yZSB7CiAgICAgICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjFzOwogICAgICAgIH0KICAgICAgICAmOmFmdGVyIHsKICAgICAgICAgICAgZGlzcGxheTogbm9uZTsKICAgICAgICB9CiAgICB9Cn0KCi5BdWRpb0Nyb3BwZXJfQ3JvcC51aS1kcmFnZ2FibGUtZHJhZ2dpbmcgLnVpLXJlc2l6YWJsZS1oYW5kbGUsCi51aS1yZXNpemFibGUtaGFuZGxlOmFjdGl2ZSwKLnVpLXJlc2l6YWJsZS1oYW5kbGU6aG92ZXIgewogICAgY3Vyc29yOiBub25lOwogICAgLlRpbWVNYXJrZXIgewogICAgICAgIGRpc3BsYXk6IGJsb2NrOwogICAgfQogICAgJjpiZWZvcmUgewogICAgICAgIHRyYW5zaXRpb246IGFsbCAwLjFzOwogICAgICAgIHRyYW5zZm9ybTogc2NhbGVYKC4yNSk7CiAgICB9CiAgICAmOmFmdGVyIHsKICAgICAgICBkaXNwbGF5OiBub25lOwogICAgfQp9CgouQ3JvcF9EdXJhdGlvbiB7CiAgICB6LWluZGV4OiAxOwogICAgcG9zaXRpb246IGFic29sdXRlOwogICAgdG9wOiA1MCU7CiAgICBsZWZ0OiA1MCU7CiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLC01MCUpOwogICAgZm9udC1zaXplOiAuN3JlbTsKICAgIGZvbnQtd2VpZ2h0OiA2MDA7CiAgICBjb2xvcjogd2hpdGU7Cn0KCgo="},{"version":3,"sources":["AudioTrimmer.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"AudioTrimmer.vue","sourceRoot":"src/components/audio","sourcesContent":["<template>\n<!-- \n    Developer notes:\n\n    Test for orientation change while resizing. Reset if possible.\n    Test for change in width while resizing. Reset if possible.\n\n    Testing width change during no interaction and width does not adjust to AudioBox width. Reset on resize.\n    \n    Resize limit makes next drag in other direction inoperable. You have to click again to drag. Troubleshoot.\n\n    When all the way to the right. The start time can be push if you keep draggint past the limit to the right. Calculate start time limit.\n-->\n  <div ref=\"Frame\" class=\"AudioCropper_Frame\">\n    <div ref=\"Crop\" class=\"AudioCropper_Crop\">\n            <div id=\"Crop_Left\" class=\"ui-resizable-handle ui-resizable-w\" @dblclick=\"trimInput('start')\">\n                <div class=\"TimeMarker TimeStart\" ref=\"TimeMarker_Start\" :data-side=\"markerWidth.start < dragSpace.left ? 'left':'right'\"><span>{{displayTimeStart}}</span></div>\n            </div>\n            <div id=\"Crop_Right\" class=\"ui-resizable-handle ui-resizable-e\" @dblclick=\"trimInput('end')\">\n                <div class=\"TimeMarker TimeEnd\" ref=\"TimeMarker_End\" :data-side=\"markerWidth.end < dragSpace.right ? 'right':'left'\"><span>{{displayTimeEnd}}</span></div> \n            </div> \n            <div class=\"Crop_Duration\" @dblclick=\"trimInput('duration')\">{{displayComputed}}s</div>  \n    </div>\n  </div>\n</template>\n\n<script>\nimport Vue from 'vue';\nimport $ from \"jquery\";\nimport \"jquery-ui/ui/widgets/resizable\";\nimport \"jquery-ui/ui/widgets/draggable\";\nimport { AudioFunctions } from '../../mixins/AudioFunctions.js';\n\nvar limitDuration = 10;\nlet endPreviewOffset = 3;\n\nexport default {\n    name: \"AudioCropper\",\n    props: ['appData','item'],\n    mixins: [AudioFunctions],\n    data() {\n        return {\n            // Data\n            totalDuration: this.item.duration,\n            cropDuration: this.item.editable.preview.duration,\n            cropStart: this.item.editable.preview.start,\n            \n            // Display \n            dragSpace: {\n                left: 0,\n                right: 0\n            },\n            markerWidth: {\n                start: 50,\n                end: 50\n            }\n        }\n    },\n    computed:{\n        displayComputed: function() {\n            return this.trimNumber(this.cropDuration,2);\n        },\n        displayTimeStart: function() {\n            return this.trimNumber(this.cropStart,2);\n        },\n        displayTimeEnd: function() {\n            return this.trimNumber((this.cropStart + this.cropDuration),2);\n        }\n    },\n    methods: {\n        trimNumber: function(num,decimals) {\n            let number = num;\n            var s = num.toString();\n            var d = s.split(\".\");\n            if (d.length > 1) {\n                d[1] = d[1].substring(0, decimals);\n                number = parseFloat(d.join(\".\"));\n            }\n            return number;\n        },        \n        setCropperSize: function(time){\n            const CropperData = this;\n            const frameWidth = CropperData.$refs.Frame.offsetWidth;\n            var pixelScale = (frameWidth/CropperData.totalDuration);\n            var cropLeft = pixelScale * time.start;\n            var cropWidth = pixelScale * time.duration;\n            \n            CropperData.$refs.Crop.style.width = cropWidth + 'px';\n            CropperData.$refs.Crop.style.left = cropLeft + 'px'\n            CropperData.setMarkerWidth();\n        },\n        setMarkerWidth: function(){\n            const CropperData = this;\n            CropperData.markerWidth = {\n                start: CropperData.$refs.TimeMarker_Start.offsetWidth,\n                end: CropperData.$refs.TimeMarker_End.offsetWidth\n            }\n            CropperData.dragSpace = {\n                left: CropperData.$refs.Crop.getBoundingClientRect().left - CropperData.$refs.Frame.getBoundingClientRect().left,\n                right: CropperData.$refs.Frame.getBoundingClientRect().right- CropperData.$refs.Crop.getBoundingClientRect().right\n            }\n        },\n        trimInput: function(property) {\n            const CropperData = this;\n            \n            // Remove previous SuperInput instance\n            Vue.set(CropperData.appData.tools.superInput,'state', false);\n\n            // Get previous time\n            let prevTime = {\n                'duration': CropperData.cropDuration,\n                'start': CropperData.cropStart\n            }\n            \n            // Reset SuperInput\n            this.$nextTick(function () {\n                Vue.set(CropperData.appData.tools.superInput,'items', []);\n\n                // Default value for SuperInput\n                let defaultValue = property === 'start' ? prevTime.start: \n                property === 'duration' ? prevTime.duration: \n                property === 'end' ? prevTime.start + prevTime.duration: \n                0;\n\n                // Add new SuperInput data\n                CropperData.appData.tools.superInput.items = [\n                    {\n                        type: 'singleLine',\n                        defaultValue: this.trimNumber(defaultValue,2),\n                        callback: function(input,callback) {\n                            let value = parseFloat(input);\n                            let timeData = {\n                                'duration': CropperData.cropDuration,\n                                'start': CropperData.cropStart\n                            };\n                            let processTrim = false;\n                            if (property === 'start') {\n                                if (value >= 0 && value <= (CropperData.totalDuration - limitDuration)) {\n                                    timeData.start = value\n                                    if ( (timeData.start + timeData.duration) < limitDuration) {\n                                        timeData.duration = limitDuration;                                    \n                                    }\n                                    if (timeData.start + timeData.duration > CropperData.totalDuration) {\n                                        timeData.duration = CropperData.totalDuration - timeData.start;\n                                    }\n                                    processTrim = true\n                                }\n                            }\n                            else if (property === 'end' || property === 'duration') {\n                                if (value >= limitDuration && value <= CropperData.totalDuration) {\n                                    if (property === 'end') {\n                                        if (value >= timeData.start + limitDuration) {\n                                            timeData.duration =  value - timeData.start;\n                                            processTrim = true;\n                                        } \n                                    }\n                                    if (property === 'duration') {\n                                        if (value <= CropperData.totalDuration - timeData.start) {\n                                            timeData.duration = value;\n                                            processTrim = true;\n                                        }\n                                    }\n                                    if ( (timeData.start + timeData.duration) < limitDuration) {\n                                        timeData.duration = limitDuration;\n                                    }\n                                    if (timeData.start + timeData.duration > CropperData.totalDuration) {\n                                        timeData.duration = CropperData.totalDuration - timeData.start;\n                                    }\n                                }\n                            }\n\n                            if (processTrim === true) {\n                                CropperData.cropStart = timeData.start;\n                                CropperData.cropDuration = timeData.duration;\n                        \n                                if (timeData.start !== prevTime.start || timeData.duration !== prevTime.duration) {\n                                    CropperData.setCropperSize(timeData);\n                                    CropperData.setMarkerWidth();\n                                    CropperData.$emit('cropData', timeData);\n                                    var options = {\n                                        playMode: 'trim',\n                                        timeData: timeData\n                                    };\n                                    if (property === 'end') {\n                                        options.seek = timeData.duration - endPreviewOffset;\n                                        options.cropSide = 'end';\n                                    }\n                                    CropperData.playSound(CropperData.appData, CropperData.item, options);\n                                }\n                                \n                                callback();\n                            }\n                        }\n                    }\n                ]\n                Vue.set(CropperData.appData.tools.superInput,'state', true);\n            });\n        }\n    },\n    mounted() {\n        const CropperData = this;\n        var getTime = function(CropperData,cropLeft,cropSize,frameSize) {\n            var start = (cropLeft/frameSize) * CropperData.totalDuration;\n            var duration = CropperData.totalDuration * (cropSize/frameSize);\n\n            var latestStart = CropperData.totalDuration - limitDuration;\n            if (start > latestStart) {\n                start = latestStart;\n            }\n            if (duration < limitDuration) {\n                duration = limitDuration;\n            }\n            \n            return {\n                'start': parseFloat(start),\n                'duration': parseFloat(duration)\n            }\n        };\n        \n        // Interactions\n        var prevTime = {\n            'duration': CropperData.cropDuration,\n            'start': CropperData.cropStart\n        }\n        $(this.$refs.Crop)\n        .draggable({\n            axis: \"x\",\n            containment: \"parent\",\n            cancel: \".ui-resizable-handle\",\n            start: function(){\n                prevTime = {\n                    'duration': CropperData.cropDuration,\n                    'start': CropperData.cropStart\n                }\n            },\n            drag: function(event, ui) {\n                var time = getTime(CropperData,ui.position.left,$(ui.helper).width(),$(ui.helper).parent().width());\n                CropperData.cropDuration = time.duration;\n                CropperData.cropStart = time.start;\n                CropperData.setMarkerWidth();\n            },\n            stop: function() {\n                // Send to audio player\n                var timeData = {\n                    'duration': CropperData.cropDuration,\n                    'start': CropperData.cropStart\n                };\n                \n                if (timeData.start !== prevTime.start || timeData.duration !== prevTime.duration) {                    \n                    CropperData.setMarkerWidth();\n                    CropperData.$emit('cropData', timeData);\n                    var options = {\n                        playMode: 'trim',\n                        timeData: timeData\n                    };\n                    CropperData.playSound(CropperData.appData, CropperData.item, options);\n                }\n            }\n        })\n        .resizable({ \n            containment: \"parent\",\n            handles: { \n                'w': '#Crop_Left',\n                'e': '#Crop_Right' \n            },\n            start: function(event, ui) {\n                prevTime = {\n                    'duration': CropperData.cropDuration,\n                    'start': CropperData.cropStart\n                }\n                var frameSize = $(ui.element).parent().width();\n                var limitWidth = frameSize/CropperData.totalDuration * limitDuration;\n                $(ui.element).resizable( \"option\", \"minWidth\", limitWidth);\n            },\n            resize: function(event, ui) {\n                var frameSize = $(ui.element).parent().width(),\n                cropSize = ui.size.width,\n                leftPosition = ui.position.left;\n                var time = getTime(CropperData,leftPosition,cropSize,frameSize);\n                CropperData.cropDuration = time.duration;\n                CropperData.cropStart = time.start;\n                CropperData.setMarkerWidth();\n            },\n            stop: function(event, ui) {\n                // Send to audio player\n                var property = $(ui.element).data('ui-resizable').axis === 'w' ? 'start': 'end'; \n                var timeData = {\n                    'duration': CropperData.cropDuration,\n                    'start': CropperData.cropStart\n                };\n\n                if (timeData.start !== prevTime.start || timeData.duration !== prevTime.duration) {\n                    CropperData.setMarkerWidth();\n                    CropperData.$emit('cropData', timeData);\n                    var options = {\n                        playMode: 'trim',\n                        timeData: timeData\n                    };\n                    if (property === 'end') {\n                        options.seek = timeData.duration - endPreviewOffset;\n                        options.cropSide = 'end';\n                    }\n                    CropperData.playSound(CropperData.appData, CropperData.item, options);\n                }\n            }\n        });\n\n        // Initialize\n        CropperData.cropDuration = CropperData.item.editable.preview.duration;\n        CropperData.cropStart = CropperData.item.editable.preview.start;\n        CropperData.setMarkerWidth();\n    },\n    beforeDestroy() {\n        $(this.$refs.$Crop).draggable(\"destroy\").resizable(\"destroy\");\n    }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.AudioCropper_Frame {\n    position: relative;\n    height: 40px;\n    width: 100%;\n    border-radius: 10px;\n    background: lightgray;\n    transition: all 1s;\n    .AudioCropper_Crop {\n        cursor: pointer;\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        background: rgb(48, 131, 255);\n    }\n}\n.ui-resizable-handle {\n    z-index: 2;\n    position: absolute;\n    top:0;\n    height: 100%;\n    width:12.5px;\n    &#Crop_Left {\n        left: 0;\n        &:before {\n            transform-origin: center left;\n        }\n    }\n    &#Crop_Right {\n        right:0;\n        &:before {\n            transform-origin: center right;\n        }\n    }\n    .TimeMarker {\n        display: none;\n        position: absolute;\n        box-sizing: border-box;\n        line-height: 17.5px;\n        height: 17.5px;\n        padding: 0 5px;\n        font-size: 65%;\n        font-weight: bold;\n        color: white;\n        background: rgb(26, 74, 145);\n        &.TimeStart {\n            top: 0;\n            left: 0;\n            transform: translate(0, 0);\n            &[data-side=\"left\"] {\n                left: auto;\n                transform: translate(-100%, 0);\n            }\n        }\n        &.TimeEnd {\n            bottom: 0;\n            right:0;\n            transform: translate(0, 0);\n            &[data-side=\"right\"] {\n                transform: translate(100%, 0);\n            }\n        }\n    }\n    &:before {\n        content: '';\n        position: absolute;\n        top:0;\n        height: 100%;\n        width:100%;\n        background: rgb(26, 74, 145);\n        transition: all 0.75s;\n    }\n    &:after {\n        content: '';\n        position: absolute;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%,-50%);\n        height: 75%;\n        width:2px;\n        background: rgba(255,255,255,0.1);\n        border-radius: 2px;\n    }\n    &:active {\n    cursor: none;\n        .TimeMarker {\n            display: block;\n        }\n        &:before {\n            transition: all 0.1s;\n        }\n        &:after {\n            display: none;\n        }\n    }\n}\n\n.AudioCropper_Crop.ui-draggable-dragging .ui-resizable-handle,\n.ui-resizable-handle:active,\n.ui-resizable-handle:hover {\n    cursor: none;\n    .TimeMarker {\n        display: block;\n    }\n    &:before {\n        transition: all 0.1s;\n        transform: scaleX(.25);\n    }\n    &:after {\n        display: none;\n    }\n}\n\n.Crop_Duration {\n    z-index: 1;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%,-50%);\n    font-size: .7rem;\n    font-weight: 600;\n    color: white;\n}\n\n\n</style>\n"]}]}